import xml
from xml.dom.minidom import Document
from collections import namedtuple
from xml.etree.ElementTree import Element, SubElement, Comment, tostring
from xml.etree import ElementTree
from xml.dom import minidom
import time
import calendar
import re
from git import *
from generatePoaXml import *
from xml_generation import *
import settings

"""

"""

class crossrefXML(object):

    def __init__(self, poa_articles, pub_date = None):
        """
        set the root node
        get the article type from the object passed in to the class
        set default values for items that are boilder plate for this XML 
        """
        self.root = Element('doi_batch')

        # set the boiler plate values
        self.contrib_types = ["author"]
        self.elife_journal_id = "eLife"
        self.elife_journal_title = "eLife"
        self.elife_journal_volume = "3"
        self.elife_email_address = 'production@elifesciences.org'
        self.elife_epub_issn = "2050-084X"
        self.elife_publisher_name = "eLife Sciences Publications, Ltd"
        self.elife_crossmark_policy = "10.7554/eLife/crossmark_policy"
        self.elife_crossmark_domain = "elifesciences.org"

        self.root.set('version', "4.3.2")
        self.root.set('xmlns', 'http://www.crossref.org/schema/4.3.2')
        self.root.set('xmlns:xsi', 'http://www.w3.org/2001/XMLSchema-instance')
        self.root.set('xmlns:fr', 'http://www.crossref.org/fundref.xsd')
        self.root.set('xmlns:schemaLocation', 'http://www.crossref.org/schema/4.3.2 http://www.crossref.org/schemas/crossref4.3.2.xsd')
        self.root.set('xmlns:mml', 'http://www.w3.org/1998/Math/MathML')

        # Publication date
        if pub_date is None:
            self.pub_date = time.gmtime()
            
        # Generate batch id
        self.elife_doi_batch_id = "elife-" + time.strftime("%Y-%m-%d-%H%M%S", self.pub_date) + "-PoA"

        # set comment
        generated = time.strftime("%Y-%m-%d %H:%M:%S")
        last_commit = get_last_commit_to_master()
        comment = Comment('generated by eLife at ' + generated + ' from version ' + last_commit)
        self.root.append(comment)

        self.build(self.root, poa_articles)

    def build(self, root, poa_articles):
        self.set_head(self.root)
        self.set_body(self.root, poa_articles)

    def set_head(self, parent):
        self.head = SubElement(parent, 'head')
        self.doi_batch_id = SubElement(self.head, 'doi_batch_id')
        self.doi_batch_id.text = self.elife_doi_batch_id
        self.timestamp = SubElement(self.head, 'timestamp')
        self.timestamp.text = str(calendar.timegm(self.pub_date))
        self.set_depositor(self.head)
        self.registrant = SubElement(self.head, 'registrant')
        self.registrant.text = self.elife_journal_title

    def set_depositor(self, parent):
        self.depositor = SubElement(parent, 'depositor')
        self.name = SubElement(self.depositor, 'name')
        self.name.text = self.elife_journal_title
        self.email_address = SubElement(self.depositor, 'email_address')
        self.email_address.text = self.elife_email_address

    def set_body(self, parent, poa_articles):
        self.body = SubElement(parent, 'body')
        self.set_journal(self.body, poa_articles)
        
    def set_journal(self, parent, poa_articles):
        self.journal = SubElement(parent, 'journal')
        self.set_journal_metadata(self.journal)
        
        self.journal_issue = SubElement(self.journal, 'journal_issue')
        
        #self.publication_date = self.set_date(self.journal_issue, poa_article, 'publication_date')
        
        self.set_publication_date(self.journal_issue, self.pub_date)

        self.journal_volume = SubElement(self.journal_issue, 'journal_volume')
        self.volume = SubElement(self.journal_volume, 'volume')
        self.volume.text = self.elife_journal_volume
        
        # Add journal article
        for poa_article in poa_articles:
            self.set_journal_article(self.journal, poa_article)

    def set_journal_metadata(self, parent):
        # journal_metadata
        journal_metadata = SubElement(parent, 'journal_metadata')
        journal_metadata.set("language", "en")
        self.full_title = SubElement(journal_metadata, 'full_title')
        self.full_title.text = self.elife_journal_title
        self.issn = SubElement(journal_metadata, 'issn')
        self.issn.set("media_type", "electronic")
        self.issn.text = self.elife_epub_issn
        
    def set_journal_article(self, parent, poa_article):
        self.journal_article = SubElement(parent, 'journal_article')
        self.journal_article.set("publication_type", "full_text")
        
        self.titles = SubElement(self.journal_article, 'titles')
        self.title = SubElement(self.titles, 'title')
        self.title.text = poa_article.title 
        
        for contrib_type in self.contrib_types:
            self.set_contributors(self.journal_article, poa_article, contrib_type)
        
        # Journal publication date
        self.set_publication_date(self.journal_article, self.pub_date)
        
        self.publisher_item = SubElement(self.journal_article, 'publisher_item')
        self.identifier = SubElement(self.publisher_item, 'identifier')
        self.identifier.set("id_type", "doi")
        self.identifier.text = poa_article.doi
        
        self.archive_locations = SubElement(self.journal_article, 'archive_locations')
        self.archive = SubElement(self.archive_locations, 'archive')
        self.archive.set("name", "CLOCKSS")
        
        self.set_doi_data(self.journal_article, poa_article)
        
    def set_doi_data(self, parent, poa_article):
        self.doi_data = SubElement(parent, 'doi_data')
        
        self.doi = SubElement(self.doi_data, 'doi')
        self.doi.text = poa_article.doi
        
        self.resource = SubElement(self.doi_data, 'resource')
        
        resource = 'http://elifesciences.org/lookup/doi/' + poa_article.doi
        self.resource.text = resource

    def set_contributors(self, parent, poa_article, contrib_type = None):
        # If contrib_type is None, all contributors will be added regardless of their type
        self.contributors = SubElement(parent, "contributors")

        for contributor in poa_article.contributors:
            if contrib_type:
                # Filter by contrib_type if supplied
                if contributor.contrib_type != contrib_type:
                    continue
            # Skip contributors with no surname
            if contributor.surname == "" or contributor.surname is None:
                continue
                
            self.person_name = SubElement(self.contributors, "person_name")

            self.person_name.set("contributor_role", contributor.contrib_type)
            
            if contributor.corresp == True or contributor.equal_contrib == True:
                self.person_name.set("sequence", "first")
            else:
                self.person_name.set("sequence", "additional")
                
            self.given_name = SubElement(self.person_name, "given_name")
            self.given_name.text = contributor.given_name
            
            self.surname = SubElement(self.person_name, "surname")
            self.surname.text = contributor.surname

    def set_publication_date(self, parent, pub_date):
        # pub_date is a python time object
        if pub_date:
            self.publication_date = SubElement(parent, 'publication_date')
            self.publication_date.set("media_type", "online")
            month = SubElement(self.publication_date, "month")
            month.text = str(self.pub_date.tm_mon).zfill(2)
            day = SubElement(self.publication_date, "day")
            day.text = str(self.pub_date.tm_mday).zfill(2)
            year = SubElement(self.publication_date, "year")
            year.text = str(self.pub_date.tm_year)

    def printXML(self):
        print self.root

    def prettyXML(self):
        encoding = 'utf-8'

        rough_string = ElementTree.tostring(self.root, encoding)
        reparsed = minidom.parseString(rough_string)

        return reparsed.toprettyxml(indent="\t", encoding = encoding)

def build_article(article_id):
    """
    Temporary duplication of instantiating an article object
    until refactoring is done
    """
    error_count = 0
    article = instantiate_article(article_id)
    if not set_abstract(article, article_id): error_count = error_count + 1
    if not set_license(article, article_id): error_count = error_count + 1
    if not set_dates(article, article_id): error_count = error_count + 1
    if not set_ethics(article, article_id): error_count = error_count + 1
    if not set_categories(article, article_id): error_count = error_count + 1
    if not set_organsims(article, article_id): error_count = error_count + 1
    if not set_author_info(article, article_id): error_count = error_count + 1
    if not set_editor_info(article, article_id): error_count = error_count + 1
    print error_count
    
    # default conflict text
    article.conflict_default = "The authors declare that no competing interests exist."
    
    return article, error_count

if __name__ == '__main__':
    
    article_ids = ["3080","3005","3100","3110"]
    poa_articles = []
    
    for article_id in article_ids:
        print "working on ", article_id
        article,error_count = build_article(article_id)
        if error_count == 0:
            poa_articles.append(article)
    
    # test the XML generator 
    eXML = crossrefXML(poa_articles)
    prettyXML = eXML.prettyXML()
    print prettyXML




